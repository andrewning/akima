
subroutine abs_smooth(x, delta_x, y)
    ! absolute value function with small quadratic in the valley
    ! so that it is C1 continuous

    implicit none
    integer, parameter :: ReKi = selected_real_kind(15, 307)

    ! in
    real(ReKi), intent(in) :: x, delta_x

    ! out
    real(ReKi), intent(out) :: y


    if (x >= delta_x) then
        y = x
    elseif (x <= -delta_x) then
        y = -x
    else
        y = x**2/(2.0*delta_x) + delta_x/2.0
    end if

end subroutine abs_smooth



subroutine setup(n, xpt, ypt, p0, p1, p2, p3, delta_x)
    ! setup the Akima spline function

    implicit none

    integer, parameter :: ReKi = selected_real_kind(15, 307)
    real(ReKi), parameter :: eps = 1d-30

    ! in
    integer, intent(in) :: n
    real(ReKi), dimension(n), intent(in) :: xpt, ypt  ! given points
    real(ReKi), intent(in) :: delta_x
    !f2py real(ReKi), intent(in) :: delta_x = 0.1

    ! out
    real(ReKi), dimension(n-1), intent(out) :: p0, p1, p2, p3  ! spline coefficients

    ! local
    integer :: i
    real(ReKi), dimension(-1:n+1) :: m
    real(ReKi), dimension(n) :: t
    real(ReKi) :: m1, m2, m3, m4, w1, w2
    real(ReKi) :: t1, t2, dx

    ! compute segment slopes
    do i = 1, n-1
        m(i) = (ypt(i+1) - ypt(i)) / (xpt(i+1) - xpt(i))
    end do

    ! estimation for end points
    m(0) = 2*m(1) - m(2)
    m(-1) = 2*m(0) - m(1)
    m(n) = 2*m(n-1) - m(n-2)
    m(n+1) = 2*m(n) - m(n-1)

    ! slope at points
    do i = 1, n
        m1 = m(i-2)
        m2 = m(i-1)
        m3 = m(i)
        m4 = m(i+1)
!         w1 = abs(m4 - m3)
!         w2 = abs(m2 - m1)
        call abs_smooth(m4 - m3, delta_x, w1)
        call abs_smooth(m2 - m1, delta_x, w2)
        if ( w1 < eps .and. w2 < eps ) then
            t(i) = 0.5*(m2 + m3)  ! special case to avoid divide by zero
        else
            t(i) = (w1*m2 + w2*m3) / (w1 + w2)
        end if
    end do

    ! polynomial cofficients
    do i = 1, n-1
        dx = xpt(i+1) - xpt(i)
        t1 = t(i)
        t2 = t(i+1)
        p0(i) = ypt(i)
        p1(i) = t1
        p2(i) = (3.0*m(i) - 2.0*t1 - t2)/dx
        p3(i) = (t1 + t2 - 2.0*m(i))/dx**2
    end do


end subroutine setup


subroutine interp(npt, n, x, xpt, p0, p1, p2, p3, &
    dp0dxpt, dp1dxpt, dp2dxpt, dp3dxpt,&
    dp0dypt, dp1dypt, dp2dypt, dp3dypt,&
    y, dydx, dydxpt, dydypt)
    ! evaluate the Akima spline and its derivatives

    implicit none
    integer, parameter :: ReKi = selected_real_kind(15, 307)

    ! in
    integer, intent(in) :: npt
    real(ReKi), dimension(npt), intent(in) :: xpt  ! given x points
    real(ReKi), dimension(npt-1), intent(in) :: p0, p1, p2, p3  ! spline coefficients
    integer, intent(in) :: n
    real(ReKi), dimension(n), intent(in) :: x  ! x values to evalute at
    real(ReKi), dimension(npt-1, npt), intent(in) :: dp0dxpt, dp1dxpt, dp2dxpt, dp3dxpt
    real(ReKi), dimension(npt-1, npt), intent(in) :: dp0dypt, dp1dypt, dp2dypt, dp3dypt

    ! out
    real(ReKi), dimension(n), intent(out) :: y  ! interpolate y values
    real(ReKi), dimension(n), intent(out) :: dydx  ! derivative of y w.r.t. x
    real(ReKi), dimension(n, npt), intent(out) :: dydxpt, dydypt  ! derivative of y w.r.t. xpt and ypt

    ! local
    integer :: i, j, k
    real(ReKi) :: dx

     ! interpolate at each point
    do i = 1, n

        ! find location in array (use end segments if out of bounds)
        if (x(i) < xpt(1)) then
            j = 1

        else
            ! linear search for now
            do j = npt-1, 1, -1
                if ( x(i) >= xpt(j)) then
                    exit
                end if
            end do
        end if

        ! evaluate polynomial (and derivative)
        dx = (x(i) - xpt(j))
        y(i) = p0(j) + p1(j)*dx + p2(j)*dx**2 + p3(j)*dx**3
        dydx(i) = p1(j) + 2*p2(j)*dx + 3*p3(j)*dx**2

        do k = 1, npt
            dydxpt(i, k) = dp0dxpt(j, k) + dp1dxpt(j, k)*dx + dp2dxpt(j, k)*dx**2 + dp3dxpt(j, k)*dx**3
            if (k == j) then
                dydxpt(i, k) = dydxpt(i, k) - dydx(i)
            end if
            dydypt(i, k) = dp0dypt(j, k) + dp1dypt(j, k)*dx + dp2dypt(j, k)*dx**2 + dp3dypt(j, k)*dx**3
        end do

    end do


end subroutine interp




!        Generated by TAPENADE     (INRIA, Tropics team)
!  Tapenade 3.8 (r5001) -  5 Nov 2013 10:56
!
!  Differentiation of setup in forward (tangent) mode:
!   variations   of useful results: p0 p1 p2 p3
!   with respect to varying inputs: xpt ypt
!   RW status of diff variables: xpt:in p0:out p1:out p2:out p3:out
!                ypt:in
SUBROUTINE SETUP_DV(n, xpt, xptd, ypt, yptd, p0, p0d, p1, p1d, p2, p2d, &
& p3, p3d, delta_x, nbdirs)
!   USE DIFFSIZES
!  Hint: nbdirsmax should be the maximum number of differentiation directions
  IMPLICIT NONE
  INTEGER, PARAMETER :: reki=SELECTED_REAL_KIND(15, 307)
  REAL(reki), PARAMETER :: eps=1d-30
! in
  INTEGER, INTENT(IN) :: n, nbdirs
! given points
  REAL(reki), DIMENSION(n), INTENT(IN) :: xpt, ypt
  REAL(reki), DIMENSION(nbdirs, n), INTENT(IN) :: xptd, yptd
  REAL(reki), INTENT(IN) :: delta_x
!f2py real(ReKi), intent(in) :: delta_x = 0.1
! out
! spline coefficients
  REAL(reki), DIMENSION(n - 1), INTENT(OUT) :: p0, p1, p2, p3
  REAL(reki), DIMENSION(nbdirs, n-1), INTENT(OUT) :: p0d, p1d, p2d, &
& p3d
! local
  INTEGER :: i
  REAL(reki), DIMENSION(-1:n + 1) :: m
  REAL(reki), DIMENSION(nbdirs, -1:n+1) :: md
  REAL(reki), DIMENSION(n) :: t
  REAL(reki), DIMENSION(nbdirs, n) :: td
  REAL(reki) :: m1, m2, m3, m4, w1, w2
  REAL(reki), DIMENSION(nbdirs) :: m1d, m2d, m3d, m4d, w1d, w2d
  REAL(reki) :: t1, t2, dx
  REAL(reki), DIMENSION(nbdirs) :: t1d, t2d, dxd
  INTRINSIC SELECTED_REAL_KIND
  REAL(reki) :: arg1
  REAL(reki), DIMENSION(nbdirs) :: arg1d
  INTEGER :: nd
!   INTEGER :: nbdirs
  DO nd=1,nbdirs
    md(nd, :) = 0.0
  END DO
! compute segment slopes
  DO i=1,n-1
    DO nd=1,nbdirs
      md(nd, i) = ((yptd(nd, i+1)-yptd(nd, i))*(xpt(i+1)-xpt(i))-(ypt(i+&
&       1)-ypt(i))*(xptd(nd, i+1)-xptd(nd, i)))/(xpt(i+1)-xpt(i))**2
    END DO
    m(i) = (ypt(i+1)-ypt(i))/(xpt(i+1)-xpt(i))
  END DO
  DO nd=1,nbdirs
! estimation for end points
    md(nd, 0) = 2*md(nd, 1) - md(nd, 2)
    md(nd, -1) = 2*md(nd, 0) - md(nd, 1)
    md(nd, n) = 2*md(nd, n-1) - md(nd, n-2)
    md(nd, n+1) = 2*md(nd, n) - md(nd, n-1)
  END DO
  m(0) = 2*m(1) - m(2)
  m(-1) = 2*m(0) - m(1)
  m(n) = 2*m(n-1) - m(n-2)
  m(n+1) = 2*m(n) - m(n-1)
  DO nd=1,nbdirs
    td(nd, :) = 0.0
  END DO
! slope at points
  DO i=1,n
    DO nd=1,nbdirs
      m1d(nd) = md(nd, i-2)
      m2d(nd) = md(nd, i-1)
      m3d(nd) = md(nd, i)
      m4d(nd) = md(nd, i+1)
!         w1 = abs(m4 - m3)
!         w2 = abs(m2 - m1)
      arg1d(nd) = m4d(nd) - m3d(nd)
    END DO
    m1 = m(i-2)
    m2 = m(i-1)
    m3 = m(i)
    m4 = m(i+1)
    arg1 = m4 - m3
    CALL ABS_SMOOTH_DV(arg1, arg1d, delta_x, w1, w1d, nbdirs)
    DO nd=1,nbdirs
      arg1d(nd) = m2d(nd) - m1d(nd)
    END DO
    arg1 = m2 - m1
    CALL ABS_SMOOTH_DV(arg1, arg1d, delta_x, w2, w2d, nbdirs)
    IF (w1 .LT. eps .AND. w2 .LT. eps) THEN
      DO nd=1,nbdirs
! special case to avoid divide by zero
        td(nd, i) = 0.5*(m2d(nd)+m3d(nd))
      END DO
      t(i) = 0.5*(m2+m3)
    ELSE
      DO nd=1,nbdirs
        td(nd, i) = ((w1d(nd)*m2+w1*m2d(nd)+w2d(nd)*m3+w2*m3d(nd))*(w1+&
&         w2)-(w1*m2+w2*m3)*(w1d(nd)+w2d(nd)))/(w1+w2)**2
      END DO
      t(i) = (w1*m2+w2*m3)/(w1+w2)
    END IF
  END DO
  DO nd=1,nbdirs
    p0d(nd, :) = 0.0
    p1d(nd, :) = 0.0
    p2d(nd, :) = 0.0
    p3d(nd, :) = 0.0
  END DO
! polynomial cofficients
  DO i=1,n-1
    dx = xpt(i+1) - xpt(i)
    t1 = t(i)
    t2 = t(i+1)
    DO nd=1,nbdirs
      dxd(nd) = xptd(nd, i+1) - xptd(nd, i)
      t1d(nd) = td(nd, i)
      t2d(nd) = td(nd, i+1)
      p0d(nd, i) = yptd(nd, i)
      p1d(nd, i) = t1d(nd)
      p2d(nd, i) = ((3.0*md(nd, i)-2.0*t1d(nd)-t2d(nd))*dx-(3.0*m(i)-2.0&
&       *t1-t2)*dxd(nd))/dx**2
      p3d(nd, i) = ((t1d(nd)+t2d(nd)-2.0*md(nd, i))*dx**2-(t1+t2-2.0*m(i&
&       ))*2*dx*dxd(nd))/(dx**2)**2
    END DO
    p0(i) = ypt(i)
    p1(i) = t1
    p2(i) = (3.0*m(i)-2.0*t1-t2)/dx
    p3(i) = (t1+t2-2.0*m(i))/dx**2
  END DO
END SUBROUTINE SETUP_DV


!  Differentiation of abs_smooth in forward (tangent) mode:
!   variations   of useful results: y
!   with respect to varying inputs: x
SUBROUTINE ABS_SMOOTH_DV(x, xd, delta_x, y, yd, nbdirs)
!   USE DIFFSIZES
!  Hint: nbdirsmax should be the maximum number of differentiation directions
  IMPLICIT NONE
  INTEGER, PARAMETER :: reki=SELECTED_REAL_KIND(15, 307)
! in
  REAL(reki), INTENT(IN) :: x, delta_x
  REAL(reki), DIMENSION(nbdirs), INTENT(IN) :: xd
  INTEGER, INTENT(IN) :: nbdirs
! out
  REAL(reki), INTENT(OUT) :: y
  REAL(reki), DIMENSION(nbdirs), INTENT(OUT) :: yd
  INTRINSIC SELECTED_REAL_KIND
  INTEGER :: nd
  IF (x .GE. delta_x) THEN
    DO nd=1,nbdirs
      yd(nd) = xd(nd)
    END DO
    y = x
  ELSE IF (x .LE. -delta_x) THEN
    DO nd=1,nbdirs
      yd(nd) = -xd(nd)
    END DO
    y = -x
  ELSE
    DO nd=1,nbdirs
      yd(nd) = 2*x*xd(nd)/(2.0*delta_x)
    END DO
    y = x**2/(2.0*delta_x) + delta_x/2.0
  END IF
END SUBROUTINE ABS_SMOOTH_DV